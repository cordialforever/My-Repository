# 摊还分析
## 二项队列

 - 二项树B0是一棵单节点树，且对于k>0，二项树Bk通过将两棵二项树Bk-1合并到一起而得到。
 - 一棵二项树的节点的秩等于它的儿子节点的个数，特别地，**Bk的根节点的秩为k**。二项队列是堆序的二项树的集合，在这个集合中对于任意的k最多可以存在一棵二项树Bk。
 - 二项树的**合并操作**：**在任意时刻，我们可以有0，1，2或3棵Bk树，它依赖于这两个优先队列是否包含一棵Bk树以及是否有一棵Bk树从前一步转入。如果存在0棵或1棵Bk树，那么它作为一棵树放到合并后的二项队列中；如果有两棵Bk树，那么它们被合并成一棵Bk+1树并且并入结果中。**
 - **插入操作**：**通过创建一个单节点二项队列并执行一次Merge来完成。**该工作所用的时间为M+1，其中M代表不在该二项队列中的二项树Bm的最小型号。
 - **删除操作**：**删除最小元通过把最小元除去并将原二项队列分裂成两个二项队列，然后再将它们合并来完成**。
 ## 位势函数
 
 - **数据结构在任意时刻的状态由一个称为位势的函数给出。这个位势函数不由程序保存，而是一个计数装置，该装置将帮助进行分析。当一些操作花费少于我们允许它们使用的时间时，则没有用到的时间就以一个更高位势的形式存储起来以备其后使用。当操作出现超出规定的时间时，则超出的时间通过位势的减少来计算。可以把位势看作一个储蓄账户。如果一次操作使用了少于指定的时间，那么这个差额就被存储起来以备后面更昂贵的操作使用**。
 - 一旦位势函数被选定，就可以写出主要的方程：T1 + H = T2。T1是一次操作的实际时间，代表需要执行一次特定操作需要的精确（遵守的）时间量。如果我们对整个序列把基本方程加起来，并且最后的位势至少像初始位势一样大，那么摊还时间就是在操作序列执行期间所用到的实际时间的一个上界（**可以认为是正负相抵和为0**）。（注：当T1在从一个操作到另一个操作变化时，T2却是稳定的）.
 - Insert、DeleteMin以及Merge对于二项队列的摊还运行时间分别是O(1)、O(log N)和O(log N)。
 ## 斜堆
 - 斜堆关键的操作是合并。为了合并两个斜堆，我们把它们的右路径合并并使之成为新的左路径。对于新路径上的每一个节点，除去最后一个，老的左子树作为右子树而附于其上。在新的左路径上的最后节点已知没有右子树。
 - 设我们有两个斜堆H1和H2并在各自的右路径上分别有r1和r2个节点。此时，执行合并的实际时间与r1+r2成正比，因此我们将省去大O记号而对右路径上的每一个节点取一个单位的时间。由于这些堆没有固定的结构模式，因此两个堆的所有节点都位于右路径上的情况是可能发生的。
 - 我们需要的是能够**获得斜堆操作效果的某种类型的位势函数**。一次合并的效果是处于右路径上的每一个节点都被移到左路径上，而其原左儿子变成新的右儿子。**一种想法是把每一个节点算入为右节点或左节点来分类，这要看节点是右儿子还是不是右儿子来定，这时我们把右节点的个数作为位势函数。虽然位势初始时为0并且总是非负的，但是问题在于这种位势在一次合并后并不减少从而不能恰当地反应在数据结构中的储备量**。
 - **定义**：一个节点P如果其右子树的后裔数至少是该p的后裔总数的一半，则称节点p是重的，否则称之为轻的。注意：一个节点的后裔个数包括该节点本身。
 - 我们将使用的位势函数是这些堆（的集合）中的重节点的个数。看起来这可能是一种好的选择，因为一条长的右路径将包含非常多的重节点。由于这条路径上的节点将要交换它们的子节点，因此这些节点将被转变成合并结果中的轻节点。
 - **定理**：合并两个斜堆的摊还时间为O(log N) 。
 - 注意：初始的位势为0而且位势总是非负的，否则摊还时间就不能成为实际时间的界而且也就没有意义了。由于Insert和DeleteMin操作基本上就是一些Merge，它们的摊还界也是O(log N)。
## 斐波那契堆
 - 斐波那契堆是以O(1)摊还时间支持所有基本的对操作的一种数据结构，但DeleteMin和Delete除外，它们花费O(log N)的摊还时间。
 - 斐波那契堆通过添加两个新的观念推广了二叉堆：1. DecreasseKey的一种不同的实现方法：我们以前看到的那种方法是把元素朝向根节点上滤。对于这种方法似乎没有理由期望O(1)的摊还时间界，因此需要一种新的方法。2. 懒惰合并：只有当两个堆需要合并时才进行合并。这类似于懒惰删除。对于懒惰合并，Merge是低廉的，但是因为懒惰合并并不实际把树结合在一起，所以DeleteMin操作可能会遇到许多的树，从而使这种操作的代价高昂。任何一次DeleteMin都可能花费线性时间，但是总能够把时间归咎到前面的一些Merge操作中去。特别地，一次昂贵的DeleteMin必须在其前面要有大量的非常低廉的Merge操作，它们能够储存额外的位势。
## 切除左式堆中的节点
 - 在二叉堆中，DecreaseKey操作是通过降低节点的值然后将其朝着根上滤直到建成堆序来实现的。在最坏的情况下，它花费O(log N)时间，这是平衡树中通向根的最长路径的长。
 - 如果优先队列的树不具有O(log N)的深度，那么这种方法不适用，如果将上述方法用到左式堆，则DecreaseKey操作可能花费O(N)时间。
## 二项队列的懒惰合并
 - 由斐波那契堆所使用的**第二个想法是懒惰合并**。我们将把这个想法用于二项队列并证明执行一次Merge操作（还有插入操作，它是一种特殊情形）的**摊还时间为O(1)**。对于DeleteMin，其摊还时间仍然是O(log N)。
 - **懒惰合并**：为了合并两个二项队列，只要把两个二项树的表连在一起，结果得到一个新的二项队列。这个新的二项队列可能含有相同大小的多棵树，因此破坏二项队列的性质。为保持一致性，将其称为**懒惰二项队列**。这是一种快速操作，该操作总是花费常数（最坏情形）时间。和前面一样，一次插入通过创建一个单节点二项队列并将其合并而完成。区别在于合并是懒惰的。DeleteMin操作要麻烦得多，因为此处需要我们最终把懒惰二项队列转变回到标准的二项队列，它仍然花费O(log N)的摊还时间——而不像以前是O(log N)最坏情形时间。为了执行DeleteMin，我们找出（并最终返回）最小元素。如前所述，我们将它从队列中删除，使得它的每一个子节点都成为一棵新的树。此时我们通过合并两个相等大小的树直至不再可能合并为止而把所有的树合并成一个二项队列（课本P344）。
 - **懒惰二项队列的摊还分析：为了进行懒惰二项队列的摊还分析，我们将用到对标准二项队列所使用的相同的位势函数。因此，懒惰二项队列的位势是树的棵数**。
 - **定理11.3**：Merge和Insert的摊还运行时间对于懒惰二项队列均为O(1)。DeleteMin的摊还运行时间为O(log N)。这里的位势函数为二项队列集合中树的棵树。初始的位势为0，而且位势总是非负的。因此，经过一系列的操作之后，总的摊还时间是总的运行时间的一个上界。对于Merge操作，实际时间为常数，而二项队列的集合中树的棵树是不变的，因此，可知摊还时间为O(1)。对于Insert操作，其实际时间是常数，而树的棵树最多增加1，因此摊还时间为O(1)。操作DeleteMin比较复杂。令R为包含最小元素的树的秩，而令T是树的棵树。于是，在DeleteMin操作开始时的位势为T。为执行一次DeleteMin，最小节点的各子节点被分离开而成为一颗一颗的树。这就产生了T+R棵树，这些树必须要合并成一个标准的二项队列。如果忽略O记号中的常数，则执行该操作的实际时间为T+R+logN。另一方面，一旦做完这些，剩下的最多可能还有log N棵树，因此位势函数最多可能增加(log N)-T。把实际时间和位势的变化加起来得到摊还时间界为2*log N + R。由于所有的树都是二项树，因此R<=log N，所以DeleteMin操作的摊还时间界O(log N)
## 斐波那契堆操作
 - 如果在二项队列中进行任意切割，那么结果得到的森林将不再是二项树的集合。因此，每一棵树的秩最多为log N将不再成立。由于已证明在懒惰二项队列中DeleteMin的摊还时间是2*log N + R，因此，对于DeleteMin的界我们需要R = O(log N)成立。
 - 为了保证R = O(log N)，我们对所有的非根节点应用下述法则：1. 将第一次（因为切除而）失去一个子节点的（非根）节点做上标记。2. 如果被标记的节点又失去另外一个儿子节点，那么将其从它的父节点切除。这个节点现在变成了一棵分离的树的根并且不再被标记。这叫作**一次级联切除**，因为在一次DecreaseKey操作中可能出现多次这种切除。
## 时间界的证明
 - 引理1. 令X是斐波那契堆中的任意节点。令Ci为X的第i个最年轻的儿子。则Ci的秩至少是i-2 。
 - 引理2. 令Fk是由F0 = 1，F1 = 1，以及Fk = Fk-1 + Fk-2的斐波那契数。秩为R>=1的任意节点至少有Fk+1个后裔（包括它自己）。
 - 引理3. 斐波那契堆中任意节点的秩为O(log N)。
 - 定理11.4. 斐波那契堆对于Insert、Merge和DecreaseKey的摊还时间界均为O(1)，而对于DeleteMin则是O(log N)。
## 伸展树
 - 在对某项X进行访问之后，一步展开通过下述三种一系列的树操作将X移至根处：单旋转、之字形旋转和一字形旋转（P348）。规定：如果在节点X执行一次树的旋转，那么旋转前P是它的父节点，G是它的祖父节点（若X不是根的儿子的话）
 - 已知，对接点X任意的树操作所需的时间正比于从跟到X的路径上的节点的个数。如果我们把每个单旋转操作计为一次旋转，把每个之字形操作或一字形操作记为两次旋转，那么任何访问的花费等于1加上旋转的次数。为了证明展开操作的O(log N)摊还时间界，需要一个位势函数，该函数对整个展开操作最多能够增加O(log N)而且在操作期间也消除所执行的旋转的次数。**该位势函数为对树T所有节点i所取的S(i)的对数和**（S(i)代表i的后裔的个数，包括i自身）。
 - 定理：在节点X展开一棵根为T的树的摊还时间最多为3(R(T) - R(X))+1 = O(log N)。（具体P350）。
 - 因为对一棵伸展树的每一次操作都需要一次展开，因此任意操作的摊还时间是在一次展开的摊还时间的一个常数倍数之内。因此，所有伸展树操作花费O(log N)摊还时间。
## Huffman
 - 对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：  

	1.  在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；
	2.  在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；
	3.  重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。

 - 构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。

 - Huffman算法的实现：构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。   查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：   如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；如果介于两个结点权重值之间，替换原来较大的结点。

	    #include<stdlib.h>
	    
	    typedef struct {
	    	int weight;//结点权重
	    	int parent, left, right;//父结点、左儿子、右儿子在数组中的位置下标
	    }HTNode,*HuffmanTree;
	    //HT数组中存放的哈夫曼树，end表示HT数组中存放结点的最终位置，s1和s2传递的是HT数组中权重值最小的两个结点在数组中的位置
	    void Select(HuffmanTree HT, int end, int* s1, int* s2) {
	    	int min1, min2;//遍历数组初始下标为1
	    	int i = 1;
	    	//找到还没构建树的结点
	    	while (HT[i].parent != 0 && i <= end) {
	    		i++;
	    	}
	    	min1 = HT[i].weight;
	    	*s1 = i;
	    	i++;
	    	while (HT[i].parent != 0 && i <= end) {
	    		i++;
	    	}
	    	//对找到的两个结点比较大小，min2为大的，min1为小的
	    	if (HT[i].weight < min1) {
	    		min2 = min1;
	    		*s2 = *s1;
	    		min1 = HT[i].weight;
	    		*s1 = i;
	    	}
	    	else {
	    		min2 = HT[i].weight;
	    		*s2 = i;
	    	}
	    	//两个结点和后续的所有为构建成树的结点做比较
	    	for (int j = i + 1; j <= end; j++) {
	    		//如果有父结点，直接跳过进行下一个
	    		if(HT[j].parent != 0){
	    			continue;
	    		}
	    		//如果比最小的还小，将min2 = min1，min1赋值新的结点的下标
	    		if (HT[j].weight < min1) {
	    			min2 = min1;
	    			min1 = HT[j].weight;
	    			*s2 = *s1;
	    			*s1 = j;
	    		}
	    		//如果介于两者之间，min2赋值为新的结点的位置下标
	    		else if (HT[j].weight >= min1 && HT[j].weight < min2) {
	    			min2 = HT[j].weight;
	    			*s2 = j;
	    		}
	    	}
	    }
	    //注意：s1和s2传入的是实参的地址,
	    //所以函数运行完成后，实参中存放的自然就是哈夫曼树中权重值最小的两个结点在数组中的位置。
	    //HT为地址传递的存储哈夫曼的数组，w为存储结点权重值的数组，n为结点的个数
	    void CreateHuffmanTree(HuffmanTree* HT, int* w, int n) {
	    	if (n <= 1)return;//如果只有一个编码就相当于0
	    	int m = 2 * n - 1;//哈夫曼树总结点数，n就是叶子结点
	    	*HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode));//0号位置不用
	    	HuffmanTree p = *HT;
	    	//初始化哈夫曼树中的所有结点
	    	for (int i = 1;i <= n;i++) {
	    		(p + i)->weight = *(w + i - 1);
	    		(p + i)->parent = 0;
	    		(p + i)->left = 0;
	    		(p + i)->right = 0;
	    	}
	    	//从数组的下标n+1开始初始化哈夫曼树中除叶子结点外的结点
	    	for (int i = n + 1; i <= m; i++)
	    	{
	    		(p + i)->weight = 0;
	    		(p + i)->parent = 0;
	    		(p + i)->left = 0;
	    		(p + i)->right = 0;
	    	}
	    	//构建哈夫曼树
	    	for (int i = n + 1;i <= m;i++) {
	    		int s1, s2;
	    		Select(*HT, i - 1, &s1, &s2);
	    		(*HT)[s1].parent = (*HT)[s2].parent = i;
	    		(*HT)[i].left = s1;
	    		(*HT)[i].right = s2;
	    		(*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;
	    	}
	    }
## 图的顺序存储

 - 使用数组存储图时，需要使用两个数组，一个数组存放图中顶点本身的数据（一维数组），另外一个数组用于存储各顶点之间的关系（二维数组）。

 - 不同类型的图，存储的方式略有不同，根据图有无权，可以将图划分为两大类：图和网 。  图，包括无向图和有向图；网，是指带权的图，包括无向网和有向网。存储方式的不同，指的是：在使用二维数组存储图中顶点之间的关系时，如果顶点之间存在边或弧，在相应位置用 1 表示，反之用 0 表示；如果使用二维数组存储网中顶点之间的关系，顶点之间如果有边或者弧的存在，在数组的相应位置存储其权值；反之用 0 表示。
	

	    #include<stdio.h>
	    	constexpr auto Max_Vertex_Num = 20; //顶点的最大个数;
	    	#define VRType int  //表示顶点之间的关系的变量类型
	    	#define InfoType char //存储弧或者边额外信息的指针变量类型
	    	#define VertexType int //图中顶点的数据类型
	    	typedef enum { DG, DN, UDG, UDN }GraphKind;       //枚举图的 4 种类型
	    	typedef struct {
	    		VRType adj; //对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。
	    		InfoType* Info; //弧或边额外含有的信息指针
	    	}ArcCell, AdjMatrix[Max_Vertex_Num][Max_Vertex_Num];
	    	typedef struct {
	    		VertexType vexs[Max_Vertex_Num];        //存储图中顶点数据
	    		AdjMatrix arcs;                         //二维数组，记录顶点之间的关系
	    		int vexnum, arcnum;                     //记录图的顶点数和弧（边）数
	    		GraphKind kind;                         //记录图的种类
	    	}MGraph;
	    	//根据顶点本身数据，判断出顶点在二维数组中的位置
	    	int LocatVex(MGraph* G, VertexType v) {
	    		int i;
	    		//遍历一维数组，找到变量v
	    		for (i = 0;i < G->vexnum;i++) {
	    			if (G->vexs[i] == v)
	    				break;
	    		}
	    		if (i > G->vexnum) {
	    			printf("no such vertex.\n");
	    			return -1;
	    		}
	    		return i;
	    	}
	    	//构造有向图
	    	void CreateDG(MGraph* G) {
	    		//输入图含有的顶点数和弧的个数
	    		scanf("%d,%d", &(G->vexnum), &(G->arcnum));
	    		//依次输入顶点本身的数据
	    		for (int i = 0;i < G->vexnum;i++) {
	    			scanf("%d", &(G->vexs[i]));
	    		}
	    		//初始化二维矩阵，全部归0，指针指向NULL
	    		for (int i = 0;i < G->vexnum;i++) {
	    			for (int j = 0;j < G->vexnum;j++) {
	    				G->arcs[i][j].adj = 0;
	    				G->arcs[i][j].Info = NULL;
	    			}
	    		}
	    		//在二维数组中添加弧的数据
	    		for (int i = 0;i < G->arcnum;i++) {
	    			int v1, v2;
	    			//输入弧头和弧尾
	    			scanf("%d,%d", &v1, &v2);
	    			//确定顶点位置
	    			int n = LocatVex(G, v1);
	    			int m = LocatVex(G, v2);
	    			//排除错误数据
	    			if (m == -1 || n == -1) {
	    				printf("no this vertex\n");
	    				return;
	    			}
	    			//将正确的弧的数据加入二维数组
	    			G->arcs[n][m].adj = 1;
	    		}
	    	}
	    	//构造无向图
	    	void CreateDN(MGraph* G) {
	    		scanf("%d,%d", &(G->vexnum), &(G->arcnum));
	    		for (int i = 0;i < G->vexnum;i++) {
	    			scanf("%d",&(G->vexs[i]));
	    		}
	    		for (int i = 0;i < G->vexnum;i++) {
	    			for (int j = 0;j < G->vexnum;j++) {
	    				G->arcs[i][j].adj = 0;
	    				G->arcs[i][j].Info = NULL;
	    			}
	    		}
	    		for (int i = 0;i < G->arcnum;i++) {
	    			int v1, v2;
	    			scanf("%d,%d", &v1, &v2);
	    			int n = LocatVex(G, v1);
	    			int m = LocatVex(G, v2);
	    			if (n == -1 || m == -1) {
	    				printf("no this vertex\n");
	    				return;
	    			}
	    			G->arcs[n][m].adj = 1;
	    			G->arcs[m][n].adj = 1;//无向图的二阶矩阵沿主对角线对称
	    		}
	    	}
	    	//构造有向网，和有向图不同的是二阶矩阵中存储的是权值。
	    	void CreateUDG(MGraph* G) {
	    		scanf("%d,%d", &(G->vexnum), &(G->arcnum));
	    		for (int i = 0;i < G->vexnum;i++) {
	    			scanf("%d", &(G->vexs[i]));
	    		}
	    		for (int i = 0;i < G->vexnum;i++) {
	    			for (int j = 0;j < G->vexnum;j++) {
	    				G->arcs[i][j].adj = 0;
	    				G->arcs[i][j].Info = NULL;
	    			}
	    		}
	    		for (int i = 0; i < G->arcnum;i++) {
	    			int v1, v2, w;
	    			scanf("%d,%d,%d", &v1, &v2, &w);
	    			int m = LocatVex(G, v1);
	    			int n = LocatVex(G, v2);
	    			if (m == -1 || n == -1) {
	    				printf("no this vertex\n");
	    				return;
	    			}
	    			G->arcs[n][m].adj = w;
	    		}
	    	}
	    	//构造无向网。和无向图唯一的区别就是二阶矩阵中存储的是权值
	    	void CreateUDN(MGraph* G) {
	    		scanf("%d,%d", &(G->vexnum), &(G->arcnum));
	    		for (int i = 0;i < G->vexnum;i++) {
	    			scanf("%d", &(G->vexs[i]));
	    		}
	    		for (int i = 0; i < G->vexnum; i++) {
	    			for (int j = 0; j < G->vexnum; j++) {
	    				G->arcs[i][j].adj = 0;
	    				G->arcs[i][j].Info = NULL;
	    			}
	    		}
	    		for (int i = 0; i < G->arcnum; i++) {
	    			int v1, v2, w;
	    			scanf("%d,%d,%d", &v1, &v2, &w);
	    			int m = LocatVex(G, v1);
	    			int n = LocatVex(G, v2);
	    			if (m == -1 || n == -1) {
	    				printf("no this vertex\n");
	    				return;
	    			}
	    			G->arcs[n][m].adj = w;
	    			G->arcs[m][n].adj = w;//矩阵对称
	    		}
	    	}
	    	void CreateGraph(MGraph* G) {
	    		//选择图的类型
	    		scanf("%d", &(G->kind));
	    		//根据所选类型，调用不同的函数实现构造图的功能
	    		switch (G->kind) {
	    		case DG:
	    			return CreateDG(G);
	    			break;
	    		case DN:
	    			return CreateDN(G);
	    			break;
	    		case UDG:
	    			return CreateUDG(G);
	    			break;
	    		case UDN:
	    			return CreateUDN(G);
	    			break;
	    		default:
	    			break;
	    		}
	    	}
	    	void PrintGraph(MGraph G) {
	    		for (int i = 0; i < G.vexnum;i++) {
	    			for (int j = 0;j < G.vexnum;j++) {
	    				printf("%d", G.arcs[i][j].adj);
	    			}
	    		}
	    	}
	    	int main() {
	    		MGraph G;//建立一个图的变量
	    		CreateGraph(&G);//调用创建函数，传入地址参数
	    		PrintGraph(G);//输出图的二阶矩阵
	    		return 0;
	    	}
具体见(http://c.biancheng.net/view/3407.html)
